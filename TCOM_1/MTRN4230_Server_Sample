MODULE MTRN4230_Server_Sample    

    ! The socket connected to the client.
    VAR socketdev client_socket;
    VAR string args{8};
    PERS string ROBargs{8};
    PERS bool flag;
    PERS string errmsg;
    PERS string jointAngles;
    PERS string eePos;
    PERS string eeOri;
    ! The host and port that we will be listening for a connection on.
    !PERS string host := "192.168.125.1";
    VAR string host := "127.0.0.1";
    CONST num port := 1025;
    
    PROC Main ()
        IF RobOS() THEN
            host := "192.168.125.1";
        ELSE
            host := "127.0.0.1";
        ENDIF
        MainServer;
        
    ENDPROC

    PROC MainServer()
        
        VAR string received_str;
        
        VAR num comma_pos_1;
        VAR num comma_pos_2;
        VAR num command_len := 8;
        
        VAR num counter;
        VAR bool ok;
        VAR num set;
        
        flag:= FALSE;
        
        ListenForAndAcceptConnection;
        
        WHILE TRUE DO
            
        IF errmsg <> "" THEN
            SocketSend client_socket \Str:=(errmsg+ "\0A");
            errmsg := "";
        ENDIF
            
        ! Receive a string from the client.
        SocketReceive client_socket \Str:=received_str;
        
        ! Receive command, should be 5 chars long
        args{1} := StrPart(received_str,1,command_len);
        
        IF StrLen(received_str) > command_len THEN
        
            ! Start going through received arguments, separated by commas
            comma_pos_1 := command_len+1;
            comma_pos_2:= StrFind(received_str,comma_pos_1+1,",");
            
            counter := 2;
            
            ! Loop while a comma is detected i.e. while we're not on the last argument
            WHILE comma_pos_2 <> StrLen(received_str)+1 DO
            
                !ok := StrToVal(StrPart(received_str,comma_pos_1+1,comma_pos_2-(comma_pos_1+1)), args{counter});
                args{counter} := StrPart(received_str,comma_pos_1+1,comma_pos_2-(comma_pos_1+1));
                comma_pos_1 := comma_pos_2;
                comma_pos_2:= StrFind(received_str,comma_pos_1+1,",");
                counter := counter + 1;
                
            ENDWHILE
            
            ! Save last argument
            args{counter} := StrPart(received_str,comma_pos_1+1,StrLen(received_str)-comma_pos_1);
            
            ! To avoid Robot movement commands being overwritten, we copy into the PERS ROBarg array
            ROBargs := args;
            
            ! Tells the Robot that a new movement command has been sent
            flag := TRUE;
            
        ENDIF
 
        
        TEST args{1}
        CASE "VACUUMON" :
            TurnVacOn;
            TPWrite "Vacuum On";
            
        CASE "VACUUMOF" :
            TurnVacOff;
            TPWrite "Vacuum Off";
            
        CASE "SETSOLEN" :
            ok := StrToVal(args{2}, set);
            SetVacSol(set);
            TPWrite ("Vacuum Solenoid " + args{2});
            
        CASE "CONVEYON" :
            TurnConOnSafely;
            TPWrite "Conveyor On";

        CASE "CONVEYOF" :
            TurnConOff;
            TPWrite "Conveyor Off";
            
        CASE "CONVDIRE" :
            ok := StrToVal(args{2}, set);
            SetConDir(set);
            TPWrite ("Conveyor Direction " + args{2});
            
        CASE "ROBPAUSE" :
            StopMove;
            TPWrite "Robot Motion Paused";
            
        CASE "ROBRESME" :
            StartMove;
            TPWrite "Robot Motion Resumed";
            
        CASE "ROBCANCL" :
            StopMoveReset;
            SETDO DO10_1, 1;
            TPWrite "Robot Motion Cancelled";     
            
        CASE "JNTANGLE" :
            SocketSend client_socket \Str:=jointAngles;
            
        CASE "EEPOSITN" :
            SocketSend client_socket \Str:=eePos;
            
        CASE "EEORIENT" :
            SocketSend client_socket \Str:=eeOri;
            
        DEFAULT :
            
        ENDTEST
        

        ! Send the string back to the client, adding a line feed character.
        !SocketSend client_socket \Str:=(args{1} + args{2} + args{3} + "\0A");
        
        ENDWHILE

        CloseConnection;
        
        ERROR
            IF ERRNO=ERR_SOCK_TIMEOUT THEN
                RETRY;
            ELSEIF ERRNO=ERR_SOCK_CLOSED THEN
                client_recover;
                RETRY;
            ELSE
                ! No error recovery handling
            ENDIF
		
    ENDPROC
    
    PROC client_recover()
        SocketClose client_socket;
        SocketCreate client_socket;
        SocketConnect client_socket, host, port;
        
        ERROR
            IF ERRNO=ERR_SOCK_TIMEOUT THEN
                RETRY;
            ELSEIF ERRNO=ERR_SOCK_CLOSED THEN
                RETURN;
            ELSE
            ! No error recovery handling
            ENDIF
    ENDPROC
    
    PROC ListenForAndAcceptConnection()
        
        ! Create the socket to listen for a connection on.
        VAR socketdev welcome_socket;
        SocketCreate welcome_socket;
        
        ! Bind the socket to the host and port.
        SocketBind welcome_socket, host, port;
        
        ! Listen on the welcome socket.
        SocketListen welcome_socket;
        
        ! Accept a connection on the host and port.
        SocketAccept welcome_socket, client_socket \Time:=WAIT_MAX;
        
        ! Close the welcome socket, as it is no longer needed.
        SocketClose welcome_socket;
        
    ENDPROC
    
    ! Close the connection to the client.
    PROC CloseConnection()
        SocketClose client_socket;
    ENDPROC
    

ENDMODULE
