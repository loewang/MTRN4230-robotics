MODULE MTRN4230_Server_Sample    

    VAR socketdev client_socket; ! Used to communicate with MATLAB
    VAR string args{8}; ! Used to contain the commands and variables sent from MATLAB
    PERS string ROBargs{8}; ! Movement commands are copied and accessible by Move_Sample
    PERS bool flag; ! Flag is set to TRUE when a command is received
    PERS string errmsg; ! Used to contain any error messages caught in Move_Sample
    PERS string jointAngles; ! Contains current joint angles
    PERS string eePos; ! Contains current end effector position
    PERS string eeOri; ! Contains current end effector orientation
    
    VAR string host := "127.0.0.1";
    CONST num port := 1025;
    
    PROC Main ()
        IF RobOS() THEN
            host := "192.168.125.1";
        ELSE
            host := "127.0.0.1";
        ENDIF
        MainServer;
        
    ENDPROC

    PROC MainServer()
        
        VAR string received_str; ! Stores command and variable string sent from MATLAB
        
        VAR num comma_pos_1; ! Keeps track of the position before the argument
        VAR num comma_pos_2; ! Keeps track of the position after the argument
        VAR num command_len := 8; ! Commands are 8 characters long
        
        VAR num counter; ! Keeps track of the argument number
        VAR bool ok; ! Bool variable just for StrToVal
        VAR num set; ! For setting values for I/Os
        
        flag:= FALSE; ! Initialise the flag to be false
        
        ListenForAndAcceptConnection; ! Connect with MATLAB       
        
        WHILE TRUE DO
            
        ! Display error message if there is one    
        IF errmsg <> "" THEN
            SocketSend client_socket \Str:=(errmsg+ "\0A");
            errmsg := ""; ! Clear error message after being displayed
        ENDIF
            
        ! Receive command string from the MATLAB
        SocketReceive client_socket \Str:=received_str;
        
        ! Begin splitting string into individual command and arguments
        args{1} := StrPart(received_str,1,command_len); 
        
        IF StrLen(received_str) > command_len THEN
        
            ! Start going through received arguments, separated by commas
            comma_pos_1 := command_len+1;
            comma_pos_2:= StrFind(received_str,comma_pos_1+1,","); ! Find the first comma
            
            counter := 2; ! First argument goes into second position of args array
            
            ! Loop while a comma is detected i.e. while not on last argument
            WHILE comma_pos_2 <> StrLen(received_str)+1 DO
            
                args{counter} := StrPart(received_str,comma_pos_1+1,comma_pos_2-(comma_pos_1+1)); ! Copy the argument
                comma_pos_1 := comma_pos_2; ! Update starting argument position
                comma_pos_2:= StrFind(received_str,comma_pos_1+1,","); ! Find the next comma
                counter := counter + 1; ! Increment counter
                
            ENDWHILE
            
            ! Save last argument
            args{counter} := StrPart(received_str,comma_pos_1+1,StrLen(received_str)-comma_pos_1);
            
            ! To avoid movement commands being overwritten by server commands, we copy into the ROBarg array
            ROBargs := args;
            
            ! Set flag to TRUE to indicate the command has been received
            flag := TRUE;
            
        ENDIF
 
        ! Server Commands - I/O Setting, Status Display
        
        TEST args{1}
        CASE "VACUUMON" : ! VacRun set to 1
            TurnVacOn;
            TPWrite "Vacuum On";
            
        CASE "VACUUMOF" : ! VacRun set to 0
            TurnVacOff;
            TPWrite "Vacuum Off";
            
        CASE "SETSOLEN" : ! VacSol set to specified value 
            ok := StrToVal(args{2}, set);
            SetVacSol(set);
            TPWrite ("Vacuum Solenoid " + args{2});
            
        CASE "CONVEYON" : ! ConRun set to 1, only if ConStat is 1
            TurnConOnSafely;
            TPWrite "Conveyor On";

        CASE "CONVEYOF" : ! ConRun set to 0
            TurnConOff; 
            TPWrite "Conveyor Off";
            
        CASE "CONVDIRE" : ! ConDir set to specified value
            ok := StrToVal(args{2}, set);
            SetConDir(set);
            TPWrite ("Conveyor Direction " + args{2});
            
        CASE "ROBPAUSE" : ! Pauses current motion task
            StopMove;
            TPWrite "Robot Motion Paused";
            
        CASE "ROBRESME" : ! Resumes previous motion task
            StartMove;
            TPWrite "Robot Motion Resumed";
            
        CASE "ROBCANCL" : ! Cancels previous motion task
            StopMoveReset;
            SETDO DO10_1, 1;
            TPWrite "Robot Motion Cancelled";     
            
        CASE "JNTANGLE" : ! Send joint angles to MATLAB
            SocketSend client_socket \Str:=jointAngles+"\0A";
            
        CASE "EEPOSITN" : ! Send end effector position to MATLAB
            SocketSend client_socket \Str:=eePos+"\0A";
            
        CASE "EEORIENT" : ! Send end effector orientation to MATLAB
            SocketSend client_socket \Str:=eeOri+"\0A";
            
        DEFAULT : ! None
            
        ENDTEST
        
    ENDWHILE

        CloseConnection;
        
        ERROR
            IF ERRNO=ERR_SOCK_TIMEOUT THEN
                RETRY;
            ELSEIF ERRNO=ERR_SOCK_CLOSED THEN
                client_recover;
                RETRY;
            ELSE
                ! No error recovery handling
            ENDIF
		
    ENDPROC
    
    PROC client_recover()
        SocketClose client_socket;
        SocketCreate client_socket;
        SocketConnect client_socket, host, port;
        
        ERROR
            IF ERRNO=ERR_SOCK_TIMEOUT THEN
                RETRY;
            ELSEIF ERRNO=ERR_SOCK_CLOSED THEN
                RETURN;
            ELSE
            ! No error recovery handling
            ENDIF
    ENDPROC
    
    PROC ListenForAndAcceptConnection()
        
        ! Create the socket to listen for a connection on.
        VAR socketdev welcome_socket;
        SocketCreate welcome_socket;
        
        ! Bind the socket to the host and port.
        SocketBind welcome_socket, host, port;
        
        ! Listen on the welcome socket.
        SocketListen welcome_socket;
        
        ! Accept a connection on the host and port.
        SocketAccept welcome_socket, client_socket \Time:=WAIT_MAX;
        
        ! Close the welcome socket, as it is no longer needed.
        SocketClose welcome_socket;
        
    ENDPROC
    
    ! Close the connection to the client.
    PROC CloseConnection()
        SocketClose client_socket;
    ENDPROC
    

ENDMODULE
