MODULE MTRN4230_Move_Sample
    
    PERS string errmsg;
    PERS string ROBargs{8};
    PERS bool flag;
    PERS bool quit;
    PERS speeddata sspeed;
    PERS string jointAngles;
    PERS string eePos;
    PERS string eeOri;
    PERS bool motionCancel;
    PERS bool inMotion;
    VAR intnum cancel;
    VAR intnum execErr;
    
    ! The Main procedure. When you select 'PP to Main' on the FlexPendant, it will go to this procedure.
    PROC Initialise()
        motionCancel := FALSE;
        
        CONNECT cancel WITH cancelTrap;
        IPers motionCancel, cancel;
        
        CONNECT execErr WITH execErrTrap;
        ISignalDO DO_EXEC_ERR, 1, execErr;
        
    ENDPROC
    
    PROC Main()
               
        ! This is a procedure defined in a System Module, so you will have access to it.
        ! This will move the robot to its calibration.
        !MoveToCalibPos;
        
        Initialise;
        ! Call a procedure that we have defined below.
        MoveJSample;
        
        ! Call another procedure that we have defined.
        !MoveLSample;
        
        ReceiveCommandLoop;
        
        ! Call another procedure, but provide some input arguments.

    ENDPROC
    
    PROC ReceiveCommandLoop()
        
        VAR bool ok;
        VAR pos coord;
        VAR robjoint pose;
        VAR jointtarget jtarg;
        VAR jointtarget jcurr;
        VAR num joint;
        VAR num jogdir;
        VAR orient quat;
        VAR orient qcurr;
        VAR robtarget rcurr;
        VAR robtarget rtarg;
        VAR num myerr;
        VAR string outputMsg;
        VAR num eulerAngles{3};      
        
        restart:
        
        jcurr := CJointT();
        jointAngles := ValToStr(jcurr.robax);
        rcurr := CRobT();
        eePos := ValToStr(rcurr.trans);
        eulerAngles{1} := EulerZYX(\X, rcurr.rot);
        eulerAngles{2} := EulerZYX(\Y, rcurr.rot);
        eulerAngles{3} := EulerZYX(\Z, rcurr.rot);
        eeOri := ValToStr(eulerAngles);
        
        
        WaitUntil flag = TRUE;
            flag := FALSE;          
            
            TEST ROBargs{1}
            
            CASE "MVPOSTAB":
                ok := StrToVal(ROBargs{2}, coord.x);
                ok := StrToVal(ROBargs{3}, coord.y);
                ok := StrToVal(ROBargs{4}, coord.z);
                
                jtarg := CalcJointT(Offs(pTableHome, coord.x, coord.y, coord.z),tSCup \ErrorNumber:=myerr);
                IF myerr = ERR_ROBLIMIT THEN
                    errmsg := "Robot Movement Limit";
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                ELSE
                    outputMsg := ("Moving to: " + ValToStr(coord) + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveAbsJ jtarg,sspeed,fine,tSCup;
                    inMotion := FALSE;
                ENDIF
                

            CASE "MVPOSCON":
                ok := StrToVal(ROBargs{2}, coord.x);
                ok := StrToVal(ROBargs{3}, coord.y);
                ok := StrToVal(ROBargs{4}, coord.z);
                
                jtarg := CalcJointT(Offs(pConvHome, coord.x, coord.y, coord.z),tSCup \ErrorNumber:=myerr);
                IF myerr = ERR_ROBLIMIT THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSE
                    errmsg := "Movement Okay";
                    outputMsg := ("Moving to: " + ValToStr(coord) + "\0A");
                    TPWrite outputMsg;   
                    
                    inMotion := TRUE;
                    MoveAbsJ jtarg,sspeed,fine,tSCup;
                    inMotion := FALSE;
                ENDIF
                
            CASE "SETPOSES":
                ok := StrToVal(ROBargs{2}, pose.rax_1);
                ok := StrToVal(ROBargs{3}, pose.rax_2);
                ok := StrToVal(ROBargs{4}, pose.rax_3);
                ok := StrToVal(ROBargs{5}, pose.rax_4);
                ok := StrToVal(ROBargs{6}, pose.rax_5);
                ok := StrToVal(ROBargs{7}, pose.rax_6);

                IF myerr = ERR_ROBLIMIT THEN 
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSE
                    jtarg.robax := pose;
                    jtarg.extax := [0, 9E9, 9E9, 9E9, 9E9, 9E9];
                                        
                    outputMsg := ("Setting axes angles to: " + ValToStr(pose) + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveAbsJ jtarg, sspeed, fine, tSCup;
                    inMotion := FALSE;

                    
                ENDIF       
                           
            CASE "JOGJOINT":
                ok := StrToVal(ROBargs{2}, joint);
                
                IF ROBargs{3} = "pos" THEN
                    jogdir := sspeed.v_tcp/10;
                ELSE
                    jogdir := -sspeed.v_tcp/10;
                ENDIF
                    
                jcurr := CJointT();
                jtarg := jcurr;
                
                TEST joint
                
                CASE 1:
                jtarg.robax.rax_1 := jcurr.robax.rax_1 + jogdir;
                
                CASE 2:
                jtarg.robax.rax_2 := jcurr.robax.rax_2 + jogdir;
                
                CASE 3:
                jtarg.robax.rax_3 := jcurr.robax.rax_3 + jogdir;
                
                CASE 4:
                jtarg.robax.rax_4 := jcurr.robax.rax_4 + jogdir;
                
                CASE 5:
                jtarg.robax.rax_5 := jcurr.robax.rax_5 + jogdir;
                
                CASE 6:
                jtarg.robax.rax_6 := jcurr.robax.rax_6 + jogdir;
                                
                ENDTEST
                
                IF abs(jtarg.robax.rax_1) > 165 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_2) > 110 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF jtarg.robax.rax_3 > 70 OR jtarg.robax.rax_3 < -110 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_4) > 160 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_5) > 120 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_1) > 400 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSE
                    outputMsg := ("Jogging joint " + ValToStr(joint) + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveAbsJ jtarg, sspeed, fine, tSCup;
                    inMotion := FALSE;       

                ENDIF
                
            CASE "EEORIENT":
                ok := StrToVal(ROBargs{2}, quat.q1);
                ok := StrToVal(ROBargs{3}, quat.q2);
                ok := StrToVal(ROBargs{4}, quat.q3);
                ok := StrToVal(ROBargs{5}, quat.q4);
                
                quat := NOrient(quat);
                
                rcurr := CRobT();
                rcurr.rot := quat;
                rtarg := rcurr;
                
                sspeed.v_ori := 100;
                
                jtarg := CalcJointT(rtarg,tSCup \ErrorNumber:=myerr);
                
                IF abs(jtarg.robax.rax_1) > 165 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_2) > 110 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF jtarg.robax.rax_3 > 70 OR jtarg.robax.rax_3 < -110 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_4) > 160 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_5) > 120 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSEIF abs(jtarg.robax.rax_1) > 400 THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSE
                    outputMsg := ("Orienting end effector to: " + ValToStr(quat) + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveL rtarg,sspeed,fine,tSCup;
                    inMotion := FALSE;  
                
!                IF myerr = ERR_ROBLIMIT THEN
!                    outputMsg := ("Robot Movement Limit" + "\0A");
!                    TPWrite outputMsg;
!                    errmsg := "Robot Movement Limit";
!                ELSE                   
!                    outputMsg := ("Orienting end effector to: " + ValToStr(quat) + "\0A");
!                    TPWrite outputMsg;
!                    errmsg := "Movement Okay";
                    
!                    inMotion := TRUE;
!                    MoveL rtarg,sspeed,fine,tSCup;
!                    inMotion := FALSE;
                    
                    !MoveAbsJ jtarg,sspeed,fine,tSCup;
                ENDIF
                
            CASE "LINMDBAS":
                rcurr := CRobT();
                rtarg := rcurr;
                qcurr := rcurr.rot;
                
                IF ROBargs{3} = "pos" THEN
                    jogdir := sspeed.v_tcp/10;
                ELSE
                    jogdir := -sspeed.v_tcp/10;
                ENDIF
                
                TEST ROBargs{2}
                
                CASE "X":
                    rtarg.trans.x := rcurr.trans.x + jogdir;
                
                CASE "Y":
                    rtarg.trans.y := rcurr.trans.y + jogdir;
                    
                CASE "Z":
                    rtarg.trans.z := rcurr.trans.z + jogdir;
                ENDTEST
                
                jtarg := CalcJointT(rtarg,tSCup \ErrorNumber:=myerr);
                
                IF myerr = ERR_ROBLIMIT THEN
                    outputMsg := ("Robot Movement Limit" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Robot Movement Limit";
                ELSE
                    outputMsg := ("Linear mode, rel. base, axis " + ROBargs{2} + " in the " + ROBargs{3} + " direction" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveL rtarg,sspeed,fine,tSCup;
                    inMotion := FALSE;
                ENDIF
            
            CASE "LINMDEND":
                rcurr := CRobT();
                
                IF ROBargs{3} = "pos" THEN
                    jogdir := sspeed.v_tcp/10;
                ELSE
                    jogdir := -sspeed.v_tcp/10;
                ENDIF
                
                TEST ROBargs{2}
                
                CASE "X":
                        rtarg := RelTool(rcurr,jogdir,0,0);
                
                CASE "Y":
                        rtarg := RelTool(rcurr,0,jogdir,0);
                    
                CASE "Z":
                        rtarg := RelTool(rcurr,0,0,jogdir);
                    
                ENDTEST
                
                jtarg := CalcJointT(rtarg,tSCup \ErrorNumber:=myerr);
                
                IF myerr = ERR_ROBLIMIT THEN
                    errmsg := "Robot Movement Limit";
                ELSE
                    outputMsg := ("Linear mode, rel. EE, axis " + ROBargs{2} + " in the " + ROBargs{3} + " direction" + "\0A");
                    TPWrite outputMsg;
                    errmsg := "Movement Okay";
                    
                    inMotion := TRUE;
                    MoveL rtarg,sspeed,fine,tSCup;
                    inMotion := FALSE;
                ENDIF
                   
            ENDTEST
        
        IF quit = FALSE THEN
            GOTO restart;
        ENDIF
        
        ERROR
        
            IF ERRNO = ERR_ROBLIMIT THEN
                errmsg:= "Robot Movement Limit" + "\0A";
                RETURN; 
            ENDIF
            
    ENDPROC
    
    TRAP cancelTrap
        IF INTNO = cancel THEN
            StorePath;
            ClearPath;
            motionCancel := FALSE;
            ReceiveCommandLoop;
        ENDIF
        
    ENDTRAP
    
    TRAP execErrTrap
        IF INTNO = execErr THEN
            StopMove;
            StopMoveReset;
            StorePath;
            ClearPath;
            ReceiveCommandLoop;
        ENDIF
    ENDTRAP
        
    PROC MoveJSample()
    
        ! 'MoveJ' executes a joint motion towards a robtarget. This is used to move the robot quickly from one point to another when that 
        !   movement does not need to be in a straight line.
        ! 'pTableHome' is a robtarget defined in system module. The exact location of this on the table has been provided to you.
        ! 'v100' is a speeddata variable, and defines how fast the robot should move. The numbers is the speed in mm/sec, in this case 100mm/sec.
        ! 'fine' is a zonedata variable, and defines how close the robot should move to a point before executing its next command. 
        !   'fine' means very close, other values such as 'z10' or 'z50', will move within 10mm and 50mm respectively before executing the next command.
        ! 'tSCup' is a tooldata variable. This has been defined in a system module, and represents the tip of the suction cup, telling the robot that we
        !   want to move this point to the specified robtarget. Please be careful about what tool you use, as using the incorrect tool will result in
        !   the robot not moving where you would expect it to. Generally you should be using
        MoveJ pTableHome, v100, fine, tSCup;
        
    ENDPROC
    
    PROC MoveLSample()
        
        ! 'MoveL' will move in a straight line between 2 points. This should be used as you approach to pick up a chocolate
        ! 'Offs' is a function that is used to offset an existing robtarget by a specified x, y, and z. Here it will be offset 100mm in the positive z direction.
        !   Note that function are called using brackets, whilst procedures and called without brackets.
        MoveL Offs(pTableHome, 0, 0, 100), v100, fine, tSCup;
        
    ENDPROC
    
    PROC VariableSample(robtarget target, num x_offset, num y_offset, num z_offset, speeddata speed, zonedata zone)
        
        ! Call 'MoveL' with the input arguments provided.
        MoveL Offs(target, x_offset, y_offset, z_offset), speed, zone, tSCup;
        
    ENDPROC
    
ENDMODULE
